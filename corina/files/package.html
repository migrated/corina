<body>

<p><code>corina.files</code> is responsible for loading and saving of
dendro datasets as files on a disk.  Every file format has a class
that implements Filetype.</p>

<p>I have the gut feeling that 90% of the code in these classes could
be abstracted away.  It would be super to be able to make Filetype an
interface, and have a "DefaultFiletype" class that defines how to load
(and save -- or not) a filetype based only on some simple rules.
These rules tend to be very similar between filetypes.</p>



<h2>How to use in an application</h2>

<p>Loading a sample from disk is very simple: just pass the filename
to the constructor.  Be sure to catch its exceptions:</p>

<pre>
/* load a file, any type */
try {
    mySample = new Sample("Some Data File.raw");
} catch (WrongFiletypeException wfte) {
    System.err.println("That doesn't look like a dendro dataset.");
} catch (FileNotFoundException fnfe) {
    System.err.println("No file there!");
} catch (IOException ioe) {
    System.err.println("Oops, something happened: " + ioe.getMessage());
}
</pre>

<p>Saving is just as easy:</p>

<pre>
/* save a file, Corina format */
try {
    mySample.save("G:\\DATA\\TMP\\OUTPUT.TUC");
} catch (IOException ioe) {
    System.err.println("error: " + ioe.getMessage());
}
</pre>



<h2>How to add a new file format</h2>

<p>Implementing a new file format is also straightforward.  Simply add
a class to package <code>edu.cornell.dendro.corina.files</code> that
implements Loadable and Saveable (unless for some strange reason you
need only one of these, but users should generally be able to expect
to load any format they can save, and vice versa).  The object will
get created once, and have one method run, so it shouldn't need a
constructor or any data fields; everything is local to the load and
save methods.  It <em>can</em>, however, have supplementary private
methods to help readability (save calls saveMeta(), saveData(),
saveWJ(), etc.).</p>

<p>The load method takes a string representing the filename, and
returns a Sample.  It can throw a FileNotFoundException or an
IOException.  You can use a java.io.StreamTokenizer to parse the input
file, but this isn't required.  (Actually, StreamTokenizer is
sufficiently primitive I only use it for part of Corina's loader.  I'm
not sure it's very useful.)  Simpler file formats (fixed-width fields,
or one datum per line) may not need very sophisticated parsing at all,
while more complex formats may require a lex-like package.</p>

<p>The save method takes a string representing the filename, and the
Sample to save.  It can throw an IOException.  The java.text package
may be useful.</p>

<p>If you need an example, the file format {@link
edu.cornell.dendro.corina.files.TwoColumn} is about as simple as they
come.  {@link edu.cornell.dendro.corina.files.Corina} demonstrates a
more complex file format that uses StreamTokenizer.<p>

<p>If you think it'll solve more problems than it causes, consider
adding your file format to Sample's load() method.  Right now, it
auto-detects Corina, Tucson, 2-column, and some other formats.  The
idea is that 99% of all files will be Corina, Tucson files will come
along now and then, and 2-column is a good last-ditch effort to load
the thing.



<h2>Rationale</h2>

<p>This isn't the most intuitively-designed package, so here's a brief
explanation of why it ended up this way.</p>

<p>Loading and saving shouldn't be methods of Sample, because then to
add formats you'd need to either subclass Sample (extra method
lookups, tree of subclasses for the same object) or add lots of
saveAsXYZ() methods (one really huge source file, can't add formats at
runtime), neither of which is very appealing.</p>

<p>The obvious solution is to make a class for file formats.
(Originally, and perhaps again in the future, some file formats will
be loadable or saveable but not the other.  Loading and saving are
pretty independent, though, so it's no terrible loss even with all
format classes Loadable and Saveable.)  The interface should be
as simple as possible, which I believe it is.</p>

<p>You might say it would seem to make more sense to write

<pre>
Corina.load("myFile.raw");
</pre>

rather than the more verbose

<pre>
(new Corina()).load("myFile.raw");
</pre>

(which also requires creation and eventual GC of an Object) and you'd
be right.  Unfortunately, in Java a static method is more like a
global function than a method: it can't be overriden.  You can bend
over backwards and say something like

<pre>
abstract class FileFormat {
    Sample load(String filename) { /* empty */ }
}

class Corina extends FileFormat {
    Sample load(String filename) {
        /* function body here */
    }
}
</pre>

but that isn't very pretty, and doesn't exactly follow the Java spec
(at least, my interpretation).  Also, you can't separate load and save
if it's a class (no multiple inheritance), and you can't make it
static if it's an interface (no static methods for interfaces).</p>

<p>The big reason, though, is that I can't say exactly why the above
code works (and, for instance, replacing <code>{ /* empty */ }</code>
with a semicolon doesn't), so I'm not going to tempt fate (and some <a
href="http://www.sun.com/">Sun</a> engineers) like that.</p>



<h2>Non-dataset file formats</h2>

<p>Another (related) issue is how to store non-dendro data.  Every now
and then, there will be some other type of data users will want to
save to disk for later use, like a crossdating grid.  Fortunately,
there are no existing ("legacy") pseudo-standard formats for these
types of data, so I get to pick: XML.</p>

<p>Background: XML is a Unicode-based, platform-independent
self-describing data file format.  XML parsers exist for most
languages on most systems, and any textual data can be stored
(Latin-5, for instance).  It's text-based, so users can read and
understand it without too much trouble.  And thanks to standards like
SAX2, you can even pick your favorite XML driver at runtime.  The only
downside: it's a little verbose, and might not be intuitive for
non-computer people (but see "Intuitive = Familiar").</p>

<p>So we have a bunch of objects to load and save in XML, and a bunch
of Samples to load and save in a dozen different formats.  How?</p>

<p><i>(I'd better think of something clever.)</i></p>

<p>Every loadable/saveable class implements Document, which defines
load() and save() methods.  For Sample, this is an auto-detecting
loader that can itself load many different types; for other classes,
it calls an inner class SAX2 handler.</p>

<h2>Future direction</h2>

Things to try:

<ul>

	    <li>An intelligent cache.  Things it could do:</li>

	      <ul>

		<li>If a sample is loaded once, keep it around: it may
		be loaded again.</li>

	      <li>If a master is loaded, consider loading its
	      elements: they may be loaded soon.</li>

	      <li>If 2 files from one directory are loaded in
	      succession, load some/all samples from that directory:
	      they may be wanted soon.</li>

	      <li>Consider loading all of the "Open Recent" samples.
	      They're likely to be loaded soon.</li>

	      </ul>

	    <li>Automatic gzip.  Since dendro files aren't very big
	    (usually &lt;1 sector, even) this probably isn't in
	    general a very big win, if at all.  For larger files
	    (e.g., masters) and where files have to be transferred
	    farther (e.g., over the internet) it could very well
	    be.</li>

	    <li><b>A well-designed reference-summary-sample
	    hierarchy.</b> (This is probably a generalization of my
	    "intelligent cache", above.)  In order to load the
	    metadata of a Sample (as an Element.loadMeta() does), the
	    entire Sample needs to be loaded, and then its data is
	    thrown away.  What a waste.  Implement some scheme like
	    this:</li>

	    <ul>

	      <li>user loads a file?  open, and keep in cache</li>

	      <li>it's a master, and user wants to see a summary of
	      the elements?  (here's where things get interesting.)
	      open each one for their summaries, but make their data
	      fields <b>weakly referenced</b>

		<li>user wants to graph the elements?  no problem, i
		probably still have all of them in memory, so it'll be
		super-fast.  the low-level will take care of
		re-loading any that happen to have been GC'd or
		modified since load</li>

		<li>user changes some metadata?  the whole sample is
		probably still in memory, and saving can be done in a
		delayed/background thread, so it's super-fast.</li>

		<li>if i ever start to run out of memory, some
		data/count/incr/decr lists will get collected, but
		that's ok: clients can only get to them from public
		methods which return strong references, re-loading the
		original files as needed.</li>

		<li>...and so forth...</li>

	    </ul>

	    <li>A well-designed native file format.  Features I'd like
	    to have:</li>

	      <ul>

	      <li>text-based; Unicode-capable</li>

	      <li>relatively compact format -- no redundant data, like all those "[1]"'s</li>

	      <li>extensible -- should be able to add more fields later without rewriting Corina</li>

	      <li>compressable?</li>

	      <li>metadata loadable separately from data -- being able
	      to load just the metadata (and the range!) without
	      loading all of the data, or being able to change some
	      metadata field without doing a whole load/save cycle, or
	      being able to redate it by simply changing a couple
	      *bytes*</li>

	      <li>(more stuff when it occurs to me)</li>

	      </ul>

</ul>



</body>
